{% extends 'blog_base.html' %}
{% from 'components/image.html' import image_center %}
{% from 'components/code.html' import highlighted_code %}
{% block blog_content %}
<p>
    This crash course on Scheme that I'm writing is the kind of course that I would had liked before starting
    to read SICP. This crash course is geared towards people who are already familiar with some programming
    language and want to start with SICP but are not really comfortable Scheme or any LISP for that matter.
    All the Python code in this blog is Python 3 compatible and all the Scheme code is MIT-Scheme compatible.
</p>
<p>
    The whole blog post is written in such a way that you should be able to pick up Scheme in an hour or so
    by typing out the programs in an online Scheme interpreter and see how the things work there. The examples
    here are in two languages namely Python and obviously Scheme. Every concept here is first introduced in
    Python and then a exact implementaion is shown in Scheme. The main reason for choosing Python is that it
    is very easy and looks a lot like pseudocode and for those who don't know the language can easily 
    undrstand the code.
</p>

<h4>Arithematic operations</h4>
<p>
    Since Scheme is a LISP it does not have operators that we can use in a infix notation, so we have operators
    like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> which have to be used in prefix notation.
    To make this easier let's visualize these operators to be nothing but functions, which they actually are
    and makes much more sense when think them to be like that.
</p>
<p>
    We will therefore assume that the languages that we are comparing Scheme do not have arithematic operators
    but have functions like <code>add()</code>, <code>subtract()</code>, <code>multiply()</code>,
    <code>divide()</code>. Let's start writing some of these arithematic operators in Python. After the Python
    block of the code the exact Scheme version of the same will be shown in the block below it.
</p>
{{
highlighted_code('python',
'''# (1 + 2) * (5 - 3) / 9
divide(multiply(add(1, 2), subtract(5, 3)), 9)  # => 0.666666666666666

# 3 + 4 + 5 + 6 + 8
add(3, 4, 5, 6, 8)  # => 26

# 9 * 9 - 3 - 5 - 3
subtract(multiply(9, 9), 3, 5, 3)  # => 70

# zero arguments
add()  # => 0
''')
}}
{{
highlighted_code('scheme',
'''; (1 + 2) * (5 - 3) / 9
(/ (* (+ 1 2) (- 5 3)) 9)  ; => Value: 2/3

; 3 + 4 + 5 + 6 + 8
(+ 3 4 5 6 8)  ; => Value: 26 

; 9 * 9 - 3 - 5 - 3
(- (* 9 9) 3 5 3) ; => Value: 70

# zero arguments
(+)  # => 0
''')
}}
<p>
    Let's first try to understand the above code. The Python part of the code has these functions
    <code>add()</code>, <code>subtract()</code>, <code>multiply()</code>, <code>divide()</code>.
    There functions take any number of arguments on which the respective operation is to be
    recursively performed. For exaple in <code>subtract()</code> the first argument will be taken
    and one after the other all the remaining arguments of <code>subtract()</code> will be 
    subtracted from till ultimately just one value is left. In case if no arguments are passed
    then a <code>0</code> will be returned.
</p>
<p>
    Now let's try to understand the Scheme code. Scheme is a typical LISP so every function call is
    enclosed in parenthesis. All the arguments passed to the function are separated with spaces.
    The first argument or the word that follows just after <code>(</code> is the call to that function.
    For eample in <code>(+ 2 3)</code>, <code>+</code> is the function call to add and <code>2</code>
    and <code>3</code> are the arguments passed to that add function.
</p>

<h4>Variables</h4>
{{highlighted_code('python',
'''# define a variable MAX that holds 500
> MAX = 500
> MAX  # => 500

# define a constant PI that returns the value of PI
> PI = 3.14
> PI  # => 3.14

# compute sum of two numbers and store it in a variable
> SUM = 3 + 6
> SUM  # => 9
''')}}
{{highlighted_code('scheme',
'''; define a variable MAX that holds 500
> (define max 500)
> max  ; => Value: 500

; define a constant PI that returns the value of PI
> (define pi 3.14)
> pi  ; => Value: 3.14

; compute sum of two numbers and store it in a variable
> (define sum (+ 3 6))
> sum  ; => Value: 9
''')}}
<p>
    Let's now look at these above things as variables, but name value binding. What exactly
    do we mean by name value binding? Simply stating it's that when we enter that name, it is
    evaluated to it's respective value that it was assigned to. This name can be later
    changed in the code be reassigning another value to that variable. To prevent that,
    we should take care about the kind of name that we give to the variables. Naming should
    be such that we do not reassign that name to something else. In other words even
    though the so called variables are not constant they should be treated as such or
    else they will not maintain
    <a href="https://en.wikipedia.org/wiki/Referential_transparency" target="_blank">referential transparency</a>.
</p>
<p>
    The syntax for defining a variable is very easy. Take the example of PI <code>(define PI 3.14)</code>.
    Whatever follows define is a new name with which we are associating a value, <code>PI</code> in this
    case is the name and <code>3.14</code> is the value associated with it. That is simply how assigning
    variables work in Scheme. The we can also evaluate an expression as a value assigned to name, this is
    done for <code>sum</code> in the code snippet shown above.
</p>
<h4>Functions</h4>
{{highlighted_code('python',
'''# Lambda implementation of square function
> square = lambda x: x * x
> square(7)   #  => 49

# Square implementation as function (syntactic sugar)
> def square(x):
      return x * x
> square(7)
''')}}
{{highlighted_code('scheme',
''';  Lambda implementation of square function
> (define square (lambda (x) (* x x)))
> (square 7)  ;  => Value: 49

; Square implementation as function (syntactic sugar)
> (define (square x) (* x x))
> (square 7)  ;  => Value: 49
''')}}
<p>
    By default in Scheme we define variable of which the value is lambda which is first shown in Python.
    In Python this is not the default way we define a function. But this is again written in that way because
    that's how it is done in Scheme. The second function that shows default way of implementing functions in Python.
    The same is shown in Scheme which is nothing but syntactic sugar for binding lambdas to name.
</p>
<h4>Conditionals</h4>
<h4>List: Getting length</h4>
<h4>List: Reversing</h4>
<h4>List: Appending two lists</h4>
<h4>List: getting the head element</h4>
<h4>List: getting the tail</h4>
<h4>List: add new element to head</h4>
<h4>Compute factorial</h4>
<h4>Compute fibonacci</h4>
<h4>Find element in the list</h4>
<h4>Sort elements in a list</h4>
<h4>Elements of a list ot a BST</h4>
<h4>Simple input and output</h4>
<h4>Writing tests</h4>
{% endblock %}

